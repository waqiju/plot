// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: pb/monitor.proto

#include "pb/monitor.pb.h"
#include "pb/monitor.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>

static const char* Guard_method_names[] = {
  "/Guard/RegisterService",
  "/Guard/JudgeTradeDay",
  "/Guard/FetchCreditStockList",
};

std::unique_ptr< Guard::Stub> Guard::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Guard::Stub> stub(new Guard::Stub(channel));
  return stub;
}

Guard::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_RegisterService_(Guard_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_JudgeTradeDay_(Guard_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_FetchCreditStockList_(Guard_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Guard::Stub::RegisterService(::grpc::ClientContext* context, const ::ServiceInfo& request, ::BaseResp* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_RegisterService_, context, request, response);
}

void Guard::Stub::experimental_async::RegisterService(::grpc::ClientContext* context, const ::ServiceInfo* request, ::BaseResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_RegisterService_, context, request, response, std::move(f));
}

void Guard::Stub::experimental_async::RegisterService(::grpc::ClientContext* context, const ::ServiceInfo* request, ::BaseResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_RegisterService_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::BaseResp>* Guard::Stub::PrepareAsyncRegisterServiceRaw(::grpc::ClientContext* context, const ::ServiceInfo& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::BaseResp>::Create(channel_.get(), cq, rpcmethod_RegisterService_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::BaseResp>* Guard::Stub::AsyncRegisterServiceRaw(::grpc::ClientContext* context, const ::ServiceInfo& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRegisterServiceRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Guard::Stub::JudgeTradeDay(::grpc::ClientContext* context, const ::TradeDayRequest& request, ::TradeDayResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_JudgeTradeDay_, context, request, response);
}

void Guard::Stub::experimental_async::JudgeTradeDay(::grpc::ClientContext* context, const ::TradeDayRequest* request, ::TradeDayResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_JudgeTradeDay_, context, request, response, std::move(f));
}

void Guard::Stub::experimental_async::JudgeTradeDay(::grpc::ClientContext* context, const ::TradeDayRequest* request, ::TradeDayResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_JudgeTradeDay_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::TradeDayResponse>* Guard::Stub::PrepareAsyncJudgeTradeDayRaw(::grpc::ClientContext* context, const ::TradeDayRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::TradeDayResponse>::Create(channel_.get(), cq, rpcmethod_JudgeTradeDay_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::TradeDayResponse>* Guard::Stub::AsyncJudgeTradeDayRaw(::grpc::ClientContext* context, const ::TradeDayRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncJudgeTradeDayRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status Guard::Stub::FetchCreditStockList(::grpc::ClientContext* context, const ::CreditStockListRequest& request, ::CreditStockList* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_FetchCreditStockList_, context, request, response);
}

void Guard::Stub::experimental_async::FetchCreditStockList(::grpc::ClientContext* context, const ::CreditStockListRequest* request, ::CreditStockList* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_FetchCreditStockList_, context, request, response, std::move(f));
}

void Guard::Stub::experimental_async::FetchCreditStockList(::grpc::ClientContext* context, const ::CreditStockListRequest* request, ::CreditStockList* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_FetchCreditStockList_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::CreditStockList>* Guard::Stub::PrepareAsyncFetchCreditStockListRaw(::grpc::ClientContext* context, const ::CreditStockListRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::CreditStockList>::Create(channel_.get(), cq, rpcmethod_FetchCreditStockList_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::CreditStockList>* Guard::Stub::AsyncFetchCreditStockListRaw(::grpc::ClientContext* context, const ::CreditStockListRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFetchCreditStockListRaw(context, request, cq);
  result->StartCall();
  return result;
}

Guard::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Guard_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Guard::Service, ::ServiceInfo, ::BaseResp>(
          [](Guard::Service* service,
             ::grpc::ServerContext* ctx,
             const ::ServiceInfo* req,
             ::BaseResp* resp) {
               return service->RegisterService(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Guard_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Guard::Service, ::TradeDayRequest, ::TradeDayResponse>(
          [](Guard::Service* service,
             ::grpc::ServerContext* ctx,
             const ::TradeDayRequest* req,
             ::TradeDayResponse* resp) {
               return service->JudgeTradeDay(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Guard_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Guard::Service, ::CreditStockListRequest, ::CreditStockList>(
          [](Guard::Service* service,
             ::grpc::ServerContext* ctx,
             const ::CreditStockListRequest* req,
             ::CreditStockList* resp) {
               return service->FetchCreditStockList(ctx, req, resp);
             }, this)));
}

Guard::Service::~Service() {
}

::grpc::Status Guard::Service::RegisterService(::grpc::ServerContext* context, const ::ServiceInfo* request, ::BaseResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Guard::Service::JudgeTradeDay(::grpc::ServerContext* context, const ::TradeDayRequest* request, ::TradeDayResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Guard::Service::FetchCreditStockList(::grpc::ServerContext* context, const ::CreditStockListRequest* request, ::CreditStockList* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* Sheep_method_names[] = {
  "/Sheep/Heartbeat",
};

std::unique_ptr< Sheep::Stub> Sheep::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Sheep::Stub> stub(new Sheep::Stub(channel));
  return stub;
}

Sheep::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Heartbeat_(Sheep_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Sheep::Stub::Heartbeat(::grpc::ClientContext* context, const ::HeardbeatRequest& request, ::HeardbeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Heartbeat_, context, request, response);
}

void Sheep::Stub::experimental_async::Heartbeat(::grpc::ClientContext* context, const ::HeardbeatRequest* request, ::HeardbeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, std::move(f));
}

void Sheep::Stub::experimental_async::Heartbeat(::grpc::ClientContext* context, const ::HeardbeatRequest* request, ::HeardbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::HeardbeatResponse>* Sheep::Stub::PrepareAsyncHeartbeatRaw(::grpc::ClientContext* context, const ::HeardbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::HeardbeatResponse>::Create(channel_.get(), cq, rpcmethod_Heartbeat_, context, request, false);
}

::grpc::ClientAsyncResponseReader< ::HeardbeatResponse>* Sheep::Stub::AsyncHeartbeatRaw(::grpc::ClientContext* context, const ::HeardbeatRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncHeartbeatRaw(context, request, cq);
  result->StartCall();
  return result;
}

Sheep::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Sheep_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Sheep::Service, ::HeardbeatRequest, ::HeardbeatResponse>(
          [](Sheep::Service* service,
             ::grpc::ServerContext* ctx,
             const ::HeardbeatRequest* req,
             ::HeardbeatResponse* resp) {
               return service->Heartbeat(ctx, req, resp);
             }, this)));
}

Sheep::Service::~Service() {
}

::grpc::Status Sheep::Service::Heartbeat(::grpc::ServerContext* context, const ::HeardbeatRequest* request, ::HeardbeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


